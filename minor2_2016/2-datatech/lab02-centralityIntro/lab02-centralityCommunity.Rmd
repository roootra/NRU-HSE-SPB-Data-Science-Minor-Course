---
title: 'DS Minor: Lab 02 -- Centrality measures and community detection Intro'
output: html_document
---

На предыдущем занятии мы поговорили о сетях в целом и посмотрели на свои сети друзей ВК (lab01-networksIntro). 

### Меры центральности

Не все вершины в сети однаково важны -- какие-то могут быть более влиятельны, какие-то менее. В разных задачах "важность" может пониматься по-разному. 

Например, можно считать в сети друзей важнее того из них, у кого больше друзей ("чем больше связей, тем лучше"). Такой показатель называется **степенью (degree)**. 

Рассмотрим на небольшом примере социальной сети - сети клуба карате (Zachary carate club).

Загрузим данные из пакета igraphdata (здесь цвет -- вручную заданные группы)
```{r message=FALSE}
library(igraph)
library(igraphdata)
data(karate) # loading nnetwork from package
```

Посчитаем степень узла
```{r}
degree(karate)
plot(karate, vertex.size = degree(karate)*1.5, 
     vertex.label.cex = degree(karate)/10,
     layout = layout.davidson.harel)
```

Еще одним показателем важности является **центральность по посредничеству, битвинность (betweenness)**. В этом случае важны вершины, которые являются посредниками между группами, находятся на "выгодном" месте.

```{r}
betweenness(karate)
plot(karate, vertex.size = betweenness(karate)/10, 
     vertex.label.cex = betweenness(karate)/150,
     layout = layout.davidson.harel)
```

### Выявление сообществ (community detection)

Основная идея выделения сообществ -- члены сообщества должны быть больше похожи друг на друга, чем на участников других сообществ (другими словами, число связей между членами одного сообщества должно быть больше, чем число связей между сообществами). 

Метод **edge betweenness**: иерархический метод, состоящий в последовательном удалении связей в порядке убывания показателей битвинности ребер (edge betweenness scores), то есть числа кратчайших путей, проходящих по рассматриваемому ребру.

```{r}
ebcommune <- edge.betweenness.community(karate)
membership(ebcommune) ## assigning nodes to communities
modularity(ebcommune)
plot(ebcommune, karate)
```

Сколько групп получилось?

**Ваша очередь:**

В примере с сетью друзей размер узла определяется битвинностью, а цвета показывают разделение на сообщества методом edge.betweenness.

* *Обратите внимание:* если вы уже создавали свою сеть, то у вас есть файл ~/graph_info.RData. В нем хранятся данные о вашей сети, собранные из ВК, и код сначала проверяет, есть ли такой файл. Поэтому когда вы будете собирать html (кнопка knit), не нужно будет опять ждать окончания скачивания данных.

Исследуйте свою сеть. Какие выводы вы можете сделать?